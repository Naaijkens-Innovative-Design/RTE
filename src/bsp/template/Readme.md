# YAPLC architecture overvew

YAPC consists of several components including:
* Beremiz,
* matiec,
* YAPLC/IDE,
* YAPLC/RTE,
* GNU ARM embedded toolchain,
* stm32flash

# YAPLC/RTE

YAPLC/RTE is runtime environment which can run Beremiz/matiec generated softPLC.
It can be compiled in one executable file with softPLC or YAPLC/RTE may be used as PLC firmware
which may run softPLC which is compiled and linked as a separate executable file.

## ABI
YAPLC/RTE uses plc ABI for communivation with softPLC. 

The ABI if defined in src/plc_abi.h it consists of several data structures which are placed in special 
sections of executable files during the link phase.

These structures are:

* **plc_rte_abi_t** - YAPLC/RTE side ABI which is used by softPLC. The global variable of this type is placed at **plc_rte_sec** section, its address must be passed to softPLC during compile phase by means of PLC_RTE_ADDR define which is generated by YAPLC/IDE.
* **plc_app_abi_t** - softPLC side ABI which is used by YAPLC/RTE. The global variable of this type is placed at **plc_app_abi_sec** section of softPLC executabe. This structure consist of several pointers to other interface structures on softPLC side.
* **plc_loc_tbl_t** - location table generated in softPLC on compile phase. The global variable of this type is blaced at softPLC **data** section. 
This table is used by YAPLC/RTE IO manager to connect device drivers with located variables of softPLC. The table consists of location descriptors.
* **plc_loc_dsc_t** - location descriptor. This structure contains data which is used by YAPLC/RTE IO manager to communicate with softPLC.

## IO manager
YAPLC/RTE IO mansger controls PLC hardware drivers and communicates with softPLC. IO manager schedules PLCs IO activity. On each softPLC run plc_iom_get() is called before softPLC code and plc_iom_set() is called after softPLC code. Every work cycle plc_iom_poll() is called to schedule asynchronous IO activity.

IO manager workflow is:

* Init hardware.
* Check hardware.
* After softPLC cstartup code is called - check and sort locations. Locations are first sorted in three groups: **inputs**, **memories**, **outputs**. Ihside these groups locations are sorted based on IO protocol (driver) IDs. After first sort locations are checked vor validity, if no erorrs found, then protocol specific sort is done for **inputs**, **memories** and **outputs**.
* Initiate IO activities on softPLC start.
* Poll drivers every main loop cycle.
* Get and set driver variables every softPLC cycle.
* Terminate IO activities on softPLC stop.

For interface with drivers BSP must contain [PLC IO manager registry](plc_iom_reg.c)

### Driver interface
PLCs drivers have standard interface, see [plc_driver_template.c](plc_driver_template.c) for details.

## Debuger

PLC debuger is responsible for communication with YAPLC/IDE. 

The debuger can start and stop softPLC, load softPLC to the device. 

PLC debugger API is defined in [src/plc_dbg.h](../../plc_dbg.h).

High level is implemented in [src/plc_dbg.c](../../plc_dbg.c).

Low level of the debuger must be implemented in BSP as debuger serial driver, see below.

## Critical hardware resources

We need some hardware resources for RTE/softPLC to work porperly, they are:
* [RTC](plc_rtc.c) (needed for IEC STD LIB).
* Periodic interrupt source to [count time](plc_wait_tmr.c) for IOM sheduing and delays.
* Periodic interrupt source to [call softPLC](plc_tick.c) code.
* [Debug UART](plc_serial.c) for IDE connection.
* [Retain](plc_backup.c) memory (e.g. EEPROM).
* [Jumpers](plc_hw.c) or emulation.
* [Boot](plc_hw.c) pin, or emulation. 

# YAPLC/IDE

YAPLC/IDE is a set of Beremiz plugins, they are:
* A set of target plugins.
* YAPLC connector.
* Retargetable configuration plugin.

## Connector plugin
YAPLC connector use serial port to communicate with PLCs. 
We use YaPySerial library for communication as PySerial had problems with Java on Windows(R) host.

## Configuration plugin
Configuration plugin parses PLC IO MAP which is given by YAPLC target plugin and generates variables location 
three.

PLC IO map files are situated in target dirrectories. These files are plain text files which contain IO MAP descriptions
for target devices. We use pretty simple declarative description language in YAPLC configuration plugin, you may use 
any current target as a reference to write your own target IO map.

## Target plugins
Target plugins are used to: 
* build softPLCs for YAPLC tagrets, 
* give PLC IO map to configuration plugin, 
* give bootloader console command to connector plugin.

YAPLC target plugins use gcc based yaplc toolchain to build softPLCs. 
We use external bootloader utility to load softPLC to devices.
YAPLC target plugins **GetBinaryCode** returns bootloader command 
which then used by YAPLC connectors **NewPLC** method to load softPLC to YAPLC based device.

To write new target one need to 
* copy one of current targets,
* change IO map in **extensions.cfg** file.
* rename: plc_***_main.c, 
* rename ***_target class in **\_\_init\_\_.py**,
* addjust **load_addr** and **runtime_addr** fields to **\_\_init\_\_** method,
* if target is not STM32 based, then use **toolchain\_\_yaplc** as base class, add **GetBinaryCode** method.

Use **toolchain\_\_yaplc\_\_stm32** **GetBinaryCode** method as reference implementation.
